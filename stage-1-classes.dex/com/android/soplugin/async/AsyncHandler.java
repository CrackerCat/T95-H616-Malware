package com.android.soplugin.async;

import android.os.Handler;
import android.os.HandlerThread;
import com.android.soplugin.util.PLog;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
/* loaded from: /mnt/shared/apks/menSe7ni.dex */
public class AsyncHandler {
    private static final String TAG = "AsyncHandler";
    private static volatile Set<AsyncHandler> mAsyncHandlers = Collections.synchronizedSet(new HashSet());
    private Handler mWorkHandler;
    private HandlerThread mWorkerThread;

    public static AsyncHandler create(String str) {
        AsyncHandler asyncHandler = new AsyncHandler(str);
        mAsyncHandlers.add(asyncHandler);
        return asyncHandler;
    }

    public static void close(AsyncHandler asyncHandler) {
        if (asyncHandler != null) {
            try {
                asyncHandler.close();
                mAsyncHandlers.remove(asyncHandler);
            } catch (Throwable th) {
                PLog.w("close handler(" + asyncHandler + ") failed: " + th);
            }
        }
    }

    public static void destroy() {
        try {
            PLog.i("destroy ...");
            Iterator<AsyncHandler> it = mAsyncHandlers.iterator();
            if (it.hasNext()) {
                do {
                    it.next().close();
                } while (it.hasNext());
            }
        } finally {
            try {
            } finally {
            }
        }
    }

    private AsyncHandler(String str) {
        HandlerThread handlerThread = new HandlerThread(str);
        this.mWorkerThread = handlerThread;
        handlerThread.start();
        this.mWorkHandler = new Handler(this.mWorkerThread.getLooper());
        PLog.i("create handler: name=" + str + ", h=" + this.mWorkHandler + ", t=" + this.mWorkerThread);
    }

    public void postDelayed(Runnable runnable, long j) {
        try {
            Handler handler = this.mWorkHandler;
            if (handler == null) {
                PLog.w("handler closed ...");
            } else if (j > 0) {
                handler.postDelayed(runnable, j);
            } else {
                handler.post(runnable);
            }
        } catch (Throwable th) {
            PLog.w("handler post delayed failed: " + th);
        }
    }

    public void post(Runnable runnable) {
        try {
            Handler handler = this.mWorkHandler;
            if (handler == null) {
                PLog.w("handle closed ...");
            } else {
                handler.post(runnable);
            }
        } catch (Throwable th) {
            PLog.w("handler post failed: " + th);
        }
    }

    public void removeAll() {
        try {
            Handler handler = this.mWorkHandler;
            if (handler == null) {
                PLog.w("handle closed ...");
            } else {
                handler.removeCallbacksAndMessages(null);
            }
        } catch (Throwable th) {
            PLog.w("handler remove all failed: " + th);
        }
    }

    private void close() {
        try {
            PLog.i("close handler: handler=" + this.mWorkHandler + ", thread=" + this.mWorkerThread);
            Handler handler = this.mWorkHandler;
            if (handler != null) {
                handler.removeCallbacksAndMessages(null);
                this.mWorkHandler = null;
            }
            HandlerThread handlerThread = this.mWorkerThread;
            if (handlerThread == null) {
                return;
            }
            handlerThread.quit();
            this.mWorkerThread = null;
        } catch (Throwable th) {
            PLog.w("close handler failed: " + th);
        }
    }
}
